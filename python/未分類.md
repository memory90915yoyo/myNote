### namespace ###

有一個 fun_a 被呼叫, 如何將參數傳到 fun\_a1

`myfun.py`
	a1 = 'a1' 
	
	def fun_a():
		print a1
		print b1

`run1.py`

	from myfun import *

	b1 = 'b1'

	def fun_b():
		print a1
		print b1

	if __name__ == "__main__": 
		fun_b() 
		fun_a() # fun_a 無法成功執行, 因為 b1 為 myfun module 中 fun_a local variable, 可用 print global() 觀察 

`run2.py`

	import myfun

	b1 = 'b1'
	a1 = myfun.a1

	def fun_b():
		print a1
		print b1

	if __name__ == "__main__":
		fun_b()
		myfun.b1 = b1
		myfun.fun_a()

`run3.py`

	from myfun import *

	b1 = 'b1'

	def fun_b():
		print a1
		print b1

	if __name__ == "__main__":
		fun_b()
		myfun.func_globals['b1'] = b1
		fun_a()

以上範例, 主要是因為參數傳值關係所造成使用方式變得複雜. 而共用 global variable 在不同 function 傳遞, 使用另一個 module 去傳遞

`cmn_var.py`

	var1 = 123

`myfun.py`

	import cmn_var as cmn

	def myfun():
		print 'var1: {}, var2: {}'.format(cmn.var1, cmn.var2)

`run.py`

	from myfun import *
	import cmn_var as cmn

	cmn.var2 = 'bbb'
	myfun()


### getattr, setattr ###

	import sys
	
	def say(word):
		print word
	
	class Person:
		def __init__(self, name):
			self.name = name

		def getName(self):
			return self.name

	def setName(self, name):
		self.name = name

	person = Person('Tim')

	# setattr
	setattr(sys.modules[__name__], 'sayHi', say)
	sayHi('Hi')
	sayHello = say 
	sayHello('Hello')

	setattr(person, 'age', 10) 
	print person.age

	setattr(Person, 'setName', setName)
	p = Person('John')
	print p.name
	p.setName('Johnie')
	print p.name

	# getattr
	print getattr(sys.modules[__name__], 'say')
	getattr(sys.modules[__name__], 'say')('say something')
	say('someone')

	print getattr(Person, 'getName')

	print getattr(person, 'getName')
	print getattr(person, 'name')
	print person.name
	print getattr(person, 'getName')()
	print person.getName()


### exec & eval ###

	print 'eval example' 
	eval('{}*{}'.format(2, 5))

	print 'exec example1' 
	exec('{}*{}'.format(2, 5))

	print 'exec example2' 
	exec('print {}*{}'.format(2, 5))

eval 是一個把字符串當作表達式執行而回傳一個結果的函數; exec 是一個把字符串當作表達式執行但不回傳結果的函數


### iterator ###

	my_list = [1, 2, 3, 4]

	# iterator method and function
	my_iter = iter(my_list)
	next(my_iter)
	next(my_iter)

	# for python 2.x
	my_iter.next()
	my_iter.next()

	# for python 3.x
	my_iter.__next__()
	my_iter.__next__()

	#next(my_iter) # 會有問題, 因為已經到底了

	# iterator for loop:
	my_iter = iter(my_list)
	for i in my_iter:
		print i

	# iterator while loop:
	my_iter = iter(my_list)
	while True:
		try:
			print next(my_iter)
		except StopIteration:
			print 'End of Iterator'
			break;

	# class
	class PowTwo:
		def __init__(self, max=0):
			self.max = max

		def __iter__(self):
			self.n = 0
			return self

		def next(self): # for python 2.x
		# def __next__(self): # for python 3.x
			if self.n <= self.max:
				result = 2 ** self.n
				self.n += 1
				return result
			else:
				raise StopIteration

	my_class = PowTwo(3)
	my_iter = iter(my_class)
	for i in my_iter:
		print i


### decorator ###

	import functools
	
	def greet(function):
		@functools.wraps(function)
		def wrapper(name):
			print 'Hello'
			return function(name)
		return wrapper
	
	def greet_someone1(someone):
		print someone
	greet_someone1 = greet(greet_someone1)
	
	@greet
	def greet_someone2(someone):
		print someone

	def greet_something(word):
		def decorator(function):
			@functools.wraps(function)
			def wrapper(name):
				print word
				return function(name)
			return wrapper
		return decorator

	def greet_someone3(someone):
		print someone
	tmp_function = greet_something('Hey')
	greet_someone3 = tmp_function(greet_someone3)

	@greet_something('Hi')
	def greet_someone4(someone):
		print someone

	greet_someone1('John')
	print greet_someone1.func_name
	greet_someone2('Mary')
	print greet_someone2.func_name
	greet_someone3('Bill')
	print greet_someone3.func_name
	greet_someone4('Jean')
	print greet_someone4.func_name

greet 為不帶參數的 function (而參數中的 function, 是要做 decorator), 因為回傳 closure function. greet\_someone1 為一般使用方式; greet\_some2 使用 python 特有的 syntax. greet_something 是帶參數的 function (參數中的 someone是要帶入的參數, 真的做 decorator 為 內部另外定義 decorator)


### property ###

	class Ball1: 
		def __init__(self, radius): 
			self.setRadius(radius) 

		def getRadius(self): 
			return self.__radius 

		def setRadius(self, radius): 
			if radius <= 0: 
				raise ValueError('{} must be positive'.format(radius)) 
			self.__radius = radius 

	class Ball2: 
		def __init__(self, radius): 
			self.setRadius(radius) 

		def getRadius(self): 
			return self.__radius 

		def setRadius(self, radius): 
			if radius <= 0: 
				raise ValueError('{} must be positive'.format(radius)) 
			self.__radius = radius 

		def delRadius(self): 
			del self.__radius 

		radius = property(getRadius, setRadius, delRadius, 'radius property') 

	class Ball3: 
		def __init__(self, radius): 
			self.__radius = radius 

		@property 
		def radius(self): 
			return self.__radius 

		@radius.setter 
		def radius(self, radius): 
			if radius <= 0: 
				raise ValueError('{} must be positive'.format(radius)) 
			self.__radius = radius 

		@radius.deleter 
		def radius(self): 
			del self.__radius 

	print ('b1: ') 
	b1 = Ball1(1) 
	print (b1.getRadius()) 
	b1.setRadius(5) 
	print (b1.getRadius()) 

	print ('b2: ') 
	b2 = Ball2(1) 
	print ('get: {}, {}'.format(b2.getRadius(), b2.radius)) 
	b2.setRadius(5) 
	print ('get: {}, {}'.format(b2.getRadius(), b2.radius)) 
	b2.radius = 4 
	print ('get: {}, {}'.format(b2.getRadius(), b2.radius)) 

	print ('b3: ') 
	b3 = Ball3(1) 
	print b3.radius 
	# b3.radius = -1 # 帶入負值會錯誤

property 是 decorator, 用以簡化 getter, setter, delter method 使用方式

### code sytle ###

PEP8 (Python Enhancement Proposals), 中有建議

[PEP8](https://www.python.org/dev/peps/pep-0008/)

[PEP8 中文](http://wiki.jiayun.org/PEP_8_--_Style_Guide_for_Python_Code)

### code golf ###

`assign`

	# beginner python
	a = 0
	b = 0
	c = 0

	# proper python
	a, b, c = 0, 0, 0

	# code golf
	a = b = c = 0

	# beginner python
	a = 'a'
	b = 'b'
	c = 'c'

	# proper python
	a, b, c = 'a', 'b', 'c'

	# code golf
	a, b, c= 'abc'


`if else`

	# beginner python
	if a < 0:
	    b = 2 * a
	else:
	    b = 3 * a

	# proper python
	b = 2 * a if a < 0 else 3 * a

	# code golf 1
	b = a < 0 and 2 * a or 3 * a
	# code golf 2 
	b = a * (3, 2)[a<0]


`list`

	# reverse list, [1, 2, 3, 4] => [4, 3, 2, 1]
	[1, 2, 3, 4][::-1]

	#  combine two list, [a, b, c, d] + [1, 2, 3, 4] => [a1, b2, c3, d4]
	a = list("abcd")
	b = list("1234")

	[x+y for x, y in zip(a,b)]
	map(lambda x, y: x+y, a, b)
	map("".join, zip(a, b))
	map(str.__add__, a, b)
